# Development

- [Smoke Testing](#smoke-testing)
  - [Creating Test Data](#creating-test-data)
  - [Running Tests](#running-tests)
- [Upgrading Cumulus](#upgrading-cumulus)
  - [Determining the Upgrade Path](#determining-the-upgrade-path)
  - [Upgrading to the Next Version in the Upgrade Path](#upgrading-to-the-next-version-in-the-upgrade-path)

## Smoke Testing

At the moment, we don't have any automated integration tests, so we have to
manually perform smoke testing to verify correct operation of our discovery and
ingestion workflows.

### Creating Test Data

For smoke testing the discovery and ingestion of the granules of a particular
collection, we need the following:

1. **CMR JSON file for any granule within the collection**

   This file should be a CMR JSON file generated by the related CSDA pipeline
   that generates UMM-G metadata from the vendor-supplied metadata.  It must be
   placed at the same path under the directory
   `app/stacks/cumulus/resources/granules` as it will appear within the S3
   bucket where the granules will be discovered.

   For example, if the CMR JSON file is located within the source bucket at the
   key `path/to/my-granule/granule-id-cmr.json`, then the file
   should be added to this repository at the following location:
   `app/stacks/cumulus/resources/granules/path/to/my-granule/granule-id-cmr.json`

   See existing `*-cmr.json` files under `app/stacks/cumulus/resources/granules`
   for examples.

1. **Rule definition for smoke test**

   This rule definition file should be placed in the directory
   `app/stacks/cumulus/resources/rules/<NAME>___<VERSION>/` and should be named
   `<NAME>___<VERSION>_SmokeTest.json`, where `<NAME>` and `<VERSION>` are the
   short name and version of the collection, respectively.  Futher, within the
   file, pay particular attention to the following settings:

   ```json
   "meta": {
      "providerPathFormat": "'<PATH/TO/GRANULES>'<DATE_PATTERN>",
      "startDate": "yyyy-MM-DDT00:00:00Z",
      "endDate": "yyyy-MM-DDT00:00:00Z",
      "step": "P1D"
   }
   ```

   where:

   - `<PATH/TO/GRANULES>` appears within single quotes (`'`) and is the same
     relative path under `app/stacks/cumulus/resources/granules` as the CMR JSON
     file above
   - `<DATE_PATTERN>` is the appropriate date pattern for a specific day (note
     that the 4-digit year must be `yyyy` in lowercase)
   - the value of `startDate` should be the date corresponding to the CMR JSON
     file (leave the time set to midnight)
   - the value of `endDate` is exactly 1 day after the `startDate`

   See existing `*_SmokeTest.json` files under
   `app/stacks/cumulus/resources/rules` for examples.

Once a CMR JSON file and a smoke test rule are created, you must generate test
granule files:

```plain
make create-test-data
```

This will create a dummy granule file for every file listed within the
`DataGranule.ArchiveAndDistributionInformation` section of the CMR JSON file,
and will update the CMR JSON file with the correct size and checksum values for
the generated granule files.  It will then sync the files with your provider
bucket so that they can be discovered during testing.

Finally, before you can perform any tests, you must add data management items
(providers, collections, and rules) to Cumulus:

```plain
make create-data-management-items
```

### Running Tests

Once you have created test data, you can run a smoke test by first opening a
terminal in a Docker container:

```plain
make bash
```

Then, list the names of the "smoke test" rules so you can choose one to run:

```plain
cumulus rules list | jq -r .[].name | grep SmokeTest
```

Next, enable one (or more) of the listed rules as follows (where `NAME` is one
of the names listed by the previous command):

```plain
cumulus rules enable --name NAME
```

Finally, run a rule to trigger discovery and ingestion:

```plain
cumulus rules run --name NAME
```

To verify that discovery is operating as expected, follow the logs (NOTE: it may
take a minute or so before you see any logging output):

```plain
aws logs tail --follow /aws/lambda/${CUMULUS_PREFIX}-DiscoverGranules
```

Once discovery appears to be functioning properly, follow the logs for ingestion
to confirm CMR validation of the metadata (NOTE: either kill the previous
command with Ctrl-C, or open another terminal window and start another Docker
container by running `make bash`):

```plain
aws logs tail --follow /aws/lambda/${CUMULUS_PREFIX}-PostToCmr
```

If you see no output from either of the `aws logs` commands after a few minutes,
then you may need to log into the AWS Management Console and check for errors in
one or both of the following Step Functions:

- ${CUMULUS_PREFIX}-DiscoverAndQueueGranules
- ${CUMULUS_PREFIX}-IngestAndPublishGranule

## Upgrading Cumulus

### Determining the Upgrade Path

When upgrading Cumulus from version _X_ to version _Y_, unless otherwise noted
in the Cumulus release notes, it is recommended that you do _not_ directly
upgrade to version _Y_, unless version _Y_ is the version that immediately
follows _X_. Rather, you should incrementally _upgrade through each version of
Cumulus_ that follows version _X_, in order, until version _Y_ is reached.

However, with a bit of time spent reviewing the Cumulus tags and release notes,
you may be able to quickly determine that one or more versions _can_ be skipped
in the upgrade process.

For example, let's assume this repository is using Cumulus version 9.7.0, and we
want to upgrade to version 10.0.1. We must first determine the versions released
between versions 9.7.0 and 10.0.1. The easiest way to do so is to visit the
[Cumulus tags] page, where we would find the following reverse chronological
sequence (as of 10.0.1 being the latest release):

- v10.0.1
- v10.0.0
- v9.7.1
- v10.0.0-beta.0
- v9.2.4
- v9.2.3
- v9.9.0
- v9.8.0
- v9.7.0

We can immediately eliminate any versions that are less than our current version
(9.7.0) because they are backports of bug fixes for earlier versions.  We can
also eliminate any beta versions. This leaves us with the following list (after
also eliminating our current version, 9.7.0):

- v10.0.1
- v10.0.0
- v9.7.1
- ~~v10.0.0-beta.0~~
- ~~v9.2.4~~
- ~~v9.2.3~~
- v9.9.0
- v9.8.0
- ~~v9.7.0~~

Since 9.7.1 is a patch release backporting a bug fix, we can eliminate that one
as well. Finally, 10.0.1 is also a patch release, so we can "skip" 10.0.0, but we
**must** take care to follow the instructions for 10.0.0.  This leaves us with
this _potential_ upgrade path:

- v10.0.1 (**IMPORTANT:** Follow release notes for v10.0.0!)
- v9.9.0
- v9.8.0

At this point, we must look at the [release notes][Cumulus releases] for versions
9.8.0 and 9.9.0 to determine if there are any specific migration notes that
require us to make specific configuration changes to our infrastructure.  As it
turns out, neither of these versions include any migration steps for us to take.
They consist solely of some code changes that don't require us to make any
changes, other than bumping the Cumulus version.

Therefore, we can upgrade from 9.7.0 directly to 10.0.1, but we must follow the
migration steps given for the 10.0.0 release.

Regardless of the current version and the target version, the same logic can be
followed to determine the upgrade path.  Once the upgrade path is determined
(9.7.0 -> 10.0.1 [with the caveat of following migration steps for 10.0.0], in
the example above), the following section outlines how to go from one version
in the upgrade path to the next version in the path.

For each version change in the upgrade path, you must repeat the steps in the
following section. In our example above, there is only one version change (from
9.7.0 to 10.0.1, while following the migration steps for 10.0.0), so the example
requires following the steps in the next section only once.

However, if in our example, the path were 9.7.0 -> 9.9.0 -> 10.0.1, we would
have to follow the steps in the following section _twice_: once for 9.7.0 ->
9.9.0, and again for 9.9.0 -> 10.0.1.

### Upgrading to the Next Version in the Upgrade Path

Once you have determined the next version of Cumulus you want to upgrade this
repository to use (see previous section), you must first take a few steps to
prepare:

1. Get the lastest code for this repository and ensure your Docker image is
   up-to-date, as follows:

   ```bash
   git checkout main
   git pull
   make docker
   ```

1. Create a new branch named `cumulus-upgrade-VERSION`, where `VERSION` is the
   next Cumulus version in the upgrade path (as determined from the previous
   section):

   ```bash
   git checkout -b cumulus-upgrade-VERSION
   ```

1. Run the following command to update the version numbers of the Cumulus
   dependencies specified in various files.  This saves a bit of work hunting
   through the files to manually change version numbers:

   ```bash
   bin/set-cumulus-version.sh VERSION
   ```

1. Run the following command to download and initialize the new versions of the
   Cumulus Terraform modules.  **NOTE:** This may take quite a bit of time,
   perhaps 45 minutes or more, because the Cumulus Terraform module files are
   rather large, and Terraform may needlessly download each module file multiple
   times.

   ```bash
   make all-init
   ```

Now that the preparation is complete, consult the Cumulus release notes for all
of the Cumulus versions after the currently deployed version through the version
you just prepared for, as found on the [Cumulus releases] page, and continue as
follows:

1. Make a list of **all necessary code and configuration changes**, according to
   the relevant **breaking changes** and **migration steps** in the relevant
   Cumulus release notes, if any.  Sometimes, an upgrade may be so simple that
   there are no required changes to be made.
1. **Deploy** the changes to a development stack:

   ```plain
   make all-up-yes
   ```

   **NOTE:** This may take quite a bit of time to complete, perhaps 30 minutes
   or more, depending on how many changes are required.
1. To make sure discovery and ingestion still work, **create some test data**
   for a smoke test:

   ```plain
   make create-test-data
   ```

1. Run a **smoke test** by following the instructions output by the previous
   command.
1. If the smoke test fails, go back to step 1 until you get a successful smoke
   test.
1. Once the smoke test succeeds, **commit and push** all changes made to the
   branch.
1. Open a Pull Request (PR) for merging your new branch to the `main` branch.
1. After your PR is approved, merge it into the `main` branch to have it
   automatically deployed to UAT.
1. Once deployment to UAT succeeds, run a smoke test to check that the upgrade
   works as expected.  If not, make the necessary corrections.
1. Deploy to Production.

Go back to the top of this section, and repeat as necessary until you reach the
final Cumulus version in the upgrade path.

[Cumulus releases]: https://github.com/nasa/cumulus/releases
[Cumulus tags]: https://github.com/nasa/cumulus/tags
